<!DOCTYPE html>
<html lang="ja">

<head>
  <title>a</title>
  <script src="jquery-3.7.0.min.js"></script>
  <link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>
  <div class="menu">
    <label>
      <span class="editor-label">JSON</span>
      <textarea class="editor" name="editor" value="1" id="editor" cols="80" rows=50></textarea>
    </label>
    <label>
      <span class="editor-label">Preview</span>
      <canvas id="board" width="32" style="width:100%;"></canvas>
    </label>
  </div>
  <div>
    <label>
      <span class="editor-label">JSON Pallets</span>
      <textarea class="editor" name="editor_palettes" value="1" id="palettes" cols="80" rows=50></textarea>
    </label>
  </div>

  <script src="common.js"></script>
  <script src="tile.js"></script>
  <script src="test.js"></script>
  <script src="class_tileset.js"></script>
  <script src="class_palette.js"></script>
  <script>
    //
    // DOM
    //
    var canvas_ctx = $("#board")[0].getContext("2d")
    var editor = $("#editor")
    var editor_palettes = $("#palettes")

    //
    // global
    //
    var tileset = new Tileset(tile)
    var cur_palette = new Palette({})
    var palettes = {}

    var canvas_x_max = 64
    var canvas_y_max = 64
    var canvas_sw = 32
    var canvas_sh = 32

    const set_canvas_size = (x, y, sw, sh) => {
      if (canvas_x_max != x || canvas_y_max != y
        || canvas_sw != sw || canvas_sh != sh) {
        canvas_x_max = x
        canvas_y_max = y
        canvas_sw = sw
        canvas_sh = sh
        canvas_ctx.canvas.width = canvas_x_max * sw
        canvas_ctx.canvas.height = canvas_y_max * sh
      }
    }

    const reflesh = () => {
      var text = editor.val()
      var json = JSON.parse(text)[0]
      var x = 0
      var y = 0
      cur_palette = new Palette(json.object)

      canvas_ctx.clearRect(0, 0, canvas_ctx.canvas.width, canvas_ctx.canvas.height)

      var x_size = 0
      var y_size = 0
      for (const l of json.object.rows) {
        x_size = x_size > l.length ? x_size : l.length
        y_size++
      }
      set_canvas_size(x_size, y_size, tileset.width, tileset.height)

      const get_id_str = (c, a = []) => {
        var f = get_first(cur_palette.get_furniture(c))
        if (f != "null") {
          return f
        }
        var t = get_first(cur_palette.get_terrain(c))
        if (t != "null") {
          return t
        }

        for (e of a) {
          f = get_first(palettes[e].get_furniture(c))
          if (f != "null") {
            return f
          }
          t = get_first(palettes[e].get_terrain(c))
          if (t != "null") {
            return t
          }
        }
        return "null"
      }

      const draw = (canvas_ctx, e, x, y, sw, sh) => {
        if (e.bg) {
          canvas_ctx.drawImage(
            e.bg.img,
            e.bg.x, e.bg.y,
            e.bg.w, e.bg.h,
            x * sw + e.bg.offset_x, y * sh + e.bg.offset_y,
            e.bg.w, e.bg.h)
        }
        if (e.fg) {
          canvas_ctx.drawImage(
            e.fg.img,
            e.fg.x, e.fg.y,
            e.fg.w, e.fg.h,
            x * sw + e.fg.offset_x, y * sh + e.fg.offset_y,
            e.fg.w, e.fg.h)
        }
      }

      var e = tileset.load_from_id(json.object.fill_ter)
      for (x = 0; x < canvas_x_max; x++) {
        for (y = 0; y < canvas_y_max; y++) {
          draw(canvas_ctx, e, x, y, tileset.width, tileset.height)
        }
      }

      y = 0
      json.object.rows.forEach((line) => {
        var array = [...line]
        x = 0
        array.forEach(c => {
          var e = tileset.load_from_id(get_id_str(c, json.object.palettes))
          draw(canvas_ctx, e, x, y, tileset.width, tileset.height)

          const m = json.object.place_monster.find(m => {
            return m.x == x && m.y == y
          })
          if(m) {
            var e = tileset.load_from_id(m.monster)
            draw(canvas_ctx, e, x, y, tileset.width, tileset.height)
          }
          x++
        })
        y++
      })
    }

    const post_process = () => {
      return new Promise(resolve => {
        setTimeout(() => {
          reflesh()
          resolve('resolved');
        }, 500);
      })
    }
    async function asyncCall() {
      const result = await post_process()
    }

    //
    // Init
    //
    editor.val(JSON.stringify(test_data, null, 2))
    editor_palettes.val(JSON.stringify(palettes_json, null, 2))
    editor.on({
      "input": reflesh
    })
    palettes_json.forEach(j => {
      const tmp = new Palette(j)
      palettes[tmp.id] = tmp
    })

    asyncCall();

  </script>
</body>

</html>